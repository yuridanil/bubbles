<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Page Title</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <style>
        body {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
    </style>

    <script>
        let start = new Date();
        let canvas;
        let ctx;
        let n = 0;
        let
            W,
            H,
            BUBBLE_CNT = 100,
            WAVE_CNT = 1,
            DEFAULT_SIZE = 32;
        let bubbles = [];
        let waves = [];
        let svg;
        let img = new Image();

        let seatop = "#00aacc";
        let seabottom = "#003040";

        const getBubble = (opacity) => {
            const svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="${DEFAULT_SIZE}" height="${DEFAULT_SIZE}">
            <circle cx="${DEFAULT_SIZE / 2}" cy="${DEFAULT_SIZE / 2}" r="${Math.floor(DEFAULT_SIZE / 30) * 10}" fill="#ffffff" style="opacity:${opacity}; filter:drop-shadow(4px 6px 1px #ff664488) drop-shadow(-2px -4px 1px #44ffffff) blur(2px)"/>
            </svg>`;
            return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);
        }

        let bubbleImages = [];
        for (let i = 0.1; i < 0.7; i += 0.1) {
            let img = new Image();
            img.src = getBubble(i);
            bubbleImages.push(img);
        }

        let waveImages = [];
        for (let i = 0; i < WAVE_CNT; i++) {
            let img = new Image();
            waveImages.push(img);
        }

        const initBubbles = () => {
            for (let i = 0; i < BUBBLE_CNT; i++) {
                bubbles.push([
                    Math.floor(Math.random() * W), // x
                    Math.floor(Math.random() * H), // y
                    Math.random(), // r
                    Math.floor(Math.random() * bubbleImages.length), // imageIndex
                    0.5 + Math.random() * 0.5 // personal speed
                ]);
            }
            for (let i = 0; i < WAVE_CNT; i++) {
                waves.push([
                    0, // size
                    15 + Math.floor(Math.random() * 10), // 1st
                    40 + Math.floor(Math.random() * 10), // 2nd
                    65 + Math.floor(Math.random() * 10), // 3rd
                    (Math.random() > 0.5 ? 1 : -1) * Math.random() / 8 // dy
                ]);
            }
        }

        const draw = () => {
            n++;
            if (n > 1) {
                n = 0;
                if (localStorage.getItem('show') !== '0') {
                    const grad = ctx.createLinearGradient(0, 0, 0, H);
                    grad.addColorStop(0, seatop);
                    grad.addColorStop(1, seabottom);
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                waves.forEach((e, i) => {
                    // return;
                    svg = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
    <filter id="blur">
    <feGaussianBlur stdDeviation="0.2" />
    </filter>
    <g transform="translate(0, 20)">
<path d="M -50 0 T -20 ${e[0]} T20 0 T40 0 T60 0 T80 0 T120 0 L 120 -100 L -50 -100 Z" stroke="none" fill="#ffffff55"
filter="
url(#blur)
drop-shadow(15px -5px 1px rgba(255, 255, 255, 255))
drop-shadow(25px -10px 1px rgba(255, 255, 255, 255))
"/>
</g>
</svg>
            `);
                    waveImages[i].src = svg;
                    ctx.drawImage(waveImages[i], 0, 0, W, W);
                    e[0] = e[0] + e[4];
                    if (e[0] < -2 || e[0] > 2)
                        e[4] = -e[4];
                });

                if (localStorage.getItem('show') !== '0') {
                    bubbles.forEach(e => {
                        ctx.drawImage(bubbleImages[e[3]], e[0], e[1], DEFAULT_SIZE * e[2], DEFAULT_SIZE * e[2]);
                        e[1] = Math.floor(e[1] - e[2] * 3 * e[4]);
                        if (e[2] > 0.3)
                            e[0] = e[0] + (1.0 - Math.random() * 2);
                        if (e[1] < -DEFAULT_SIZE + 100) { // make a new bubble out of an old one
                            e[1] = H + DEFAULT_SIZE;
                            e[0] = Math.floor(Math.random() * W);
                        }
                    });
                }
            }
            window.requestAnimationFrame(draw);
        }

        window.onresize = () => {

            W = document.body.clientWidth;
            H = document.body.clientHeight;
            canvas.width = document.body.clientWidth;
            canvas.height = document.body.clientHeight;
        }

        window.onload = () => {
            W = document.body.clientWidth;
            H = document.body.clientHeight;

            canvas = document.getElementById("canvas");
            canvas.width = document.body.clientWidth;
            canvas.height = document.body.clientHeight;
            ctx = canvas.getContext("2d");
            initBubbles();

            window.requestAnimationFrame(draw);
        }
    </script>
</head>

<body>
    <canvas id="canvas"></canvas>

</body>

</html>
